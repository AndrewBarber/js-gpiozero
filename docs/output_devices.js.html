<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>output_devices.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Buzzer.html">Buzzer</a><ul class='methods'><li data-type='method'><a href="Buzzer.html#active_high">active_high</a></li><li data-type='method'><a href="Buzzer.html#beep">beep</a></li><li data-type='method'><a href="Buzzer.html#blink">blink</a></li><li data-type='method'><a href="Buzzer.html#close">close</a></li><li data-type='method'><a href="Buzzer.html#closed">closed</a></li><li data-type='method'><a href="Buzzer.html#is_active">is_active</a></li><li data-type='method'><a href="Buzzer.html#off">off</a></li><li data-type='method'><a href="Buzzer.html#on">on</a></li><li data-type='method'><a href="Buzzer.html#pin">pin</a></li><li data-type='method'><a href="Buzzer.html#toggle">toggle</a></li><li data-type='method'><a href="Buzzer.html#toString">toString</a></li><li data-type='method'><a href="Buzzer.html#value">value</a></li></ul></li><li><a href="CompositeDevice.html">CompositeDevice</a><ul class='methods'><li data-type='method'><a href="CompositeDevice.html#close">close</a></li><li data-type='method'><a href="CompositeDevice.html#is_active">is_active</a></li><li data-type='method'><a href="CompositeDevice.html#length">length</a></li><li data-type='method'><a href="CompositeDevice.html#namedtuple">namedtuple</a></li><li data-type='method'><a href="CompositeDevice.html#value">value</a></li></ul></li><li><a href="CompositeOutputDevice.html">CompositeOutputDevice</a><ul class='methods'><li data-type='method'><a href="CompositeOutputDevice.html#close">close</a></li><li data-type='method'><a href="CompositeOutputDevice.html#is_active">is_active</a></li><li data-type='method'><a href="CompositeOutputDevice.html#length">length</a></li><li data-type='method'><a href="CompositeOutputDevice.html#namedtuple">namedtuple</a></li><li data-type='method'><a href="CompositeOutputDevice.html#off">off</a></li><li data-type='method'><a href="CompositeOutputDevice.html#on">on</a></li><li data-type='method'><a href="CompositeOutputDevice.html#toggle">toggle</a></li><li data-type='method'><a href="CompositeOutputDevice.html#value">value</a></li></ul></li><li><a href="Device.html">Device</a><ul class='methods'><li data-type='method'><a href="Device.html#close">close</a></li><li data-type='method'><a href="Device.html#is_active">is_active</a></li><li data-type='method'><a href="Device.html#value">value</a></li></ul></li><li><a href="DigitalOutputDevice.html">DigitalOutputDevice</a><ul class='methods'><li data-type='method'><a href="DigitalOutputDevice.html#active_high">active_high</a></li><li data-type='method'><a href="DigitalOutputDevice.html#blink">blink</a></li><li data-type='method'><a href="DigitalOutputDevice.html#close">close</a></li><li data-type='method'><a href="DigitalOutputDevice.html#closed">closed</a></li><li data-type='method'><a href="DigitalOutputDevice.html#is_active">is_active</a></li><li data-type='method'><a href="DigitalOutputDevice.html#off">off</a></li><li data-type='method'><a href="DigitalOutputDevice.html#on">on</a></li><li data-type='method'><a href="DigitalOutputDevice.html#pin">pin</a></li><li data-type='method'><a href="DigitalOutputDevice.html#toggle">toggle</a></li><li data-type='method'><a href="DigitalOutputDevice.html#toString">toString</a></li><li data-type='method'><a href="DigitalOutputDevice.html#value">value</a></li></ul></li><li><a href="GPIODevice.html">GPIODevice</a><ul class='methods'><li data-type='method'><a href="GPIODevice.html#close">close</a></li><li data-type='method'><a href="GPIODevice.html#closed">closed</a></li><li data-type='method'><a href="GPIODevice.html#is_active">is_active</a></li><li data-type='method'><a href="GPIODevice.html#pin">pin</a></li><li data-type='method'><a href="GPIODevice.html#toString">toString</a></li><li data-type='method'><a href="GPIODevice.html#value">value</a></li></ul></li><li><a href="LED.html">LED</a><ul class='methods'><li data-type='method'><a href="LED.html#active_high">active_high</a></li><li data-type='method'><a href="LED.html#blink">blink</a></li><li data-type='method'><a href="LED.html#close">close</a></li><li data-type='method'><a href="LED.html#closed">closed</a></li><li data-type='method'><a href="LED.html#is_active">is_active</a></li><li data-type='method'><a href="LED.html#is_lit">is_lit</a></li><li data-type='method'><a href="LED.html#off">off</a></li><li data-type='method'><a href="LED.html#on">on</a></li><li data-type='method'><a href="LED.html#pin">pin</a></li><li data-type='method'><a href="LED.html#toggle">toggle</a></li><li data-type='method'><a href="LED.html#toString">toString</a></li><li data-type='method'><a href="LED.html#value">value</a></li></ul></li><li><a href="LEDBoard.html">LEDBoard</a><ul class='methods'><li data-type='method'><a href="LEDBoard.html#active_high">active_high</a></li><li data-type='method'><a href="LEDBoard.html#close">close</a></li><li data-type='method'><a href="LEDBoard.html#is_active">is_active</a></li><li data-type='method'><a href="LEDBoard.html#leds">leds</a></li><li data-type='method'><a href="LEDBoard.html#length">length</a></li><li data-type='method'><a href="LEDBoard.html#namedtuple">namedtuple</a></li><li data-type='method'><a href="LEDBoard.html#off">off</a></li><li data-type='method'><a href="LEDBoard.html#on">on</a></li><li data-type='method'><a href="LEDBoard.html#toggle">toggle</a></li><li data-type='method'><a href="LEDBoard.html#value">value</a></li></ul></li><li><a href="LEDCollection.html">LEDCollection</a><ul class='methods'><li data-type='method'><a href="LEDCollection.html#active_high">active_high</a></li><li data-type='method'><a href="LEDCollection.html#close">close</a></li><li data-type='method'><a href="LEDCollection.html#is_active">is_active</a></li><li data-type='method'><a href="LEDCollection.html#leds">leds</a></li><li data-type='method'><a href="LEDCollection.html#length">length</a></li><li data-type='method'><a href="LEDCollection.html#namedtuple">namedtuple</a></li><li data-type='method'><a href="LEDCollection.html#off">off</a></li><li data-type='method'><a href="LEDCollection.html#on">on</a></li><li data-type='method'><a href="LEDCollection.html#toggle">toggle</a></li><li data-type='method'><a href="LEDCollection.html#value">value</a></li></ul></li><li><a href="Motor.html">Motor</a><ul class='methods'><li data-type='method'><a href="Motor.html#backward">backward</a></li><li data-type='method'><a href="Motor.html#close">close</a></li><li data-type='method'><a href="Motor.html#closed">closed</a></li><li data-type='method'><a href="Motor.html#forward">forward</a></li><li data-type='method'><a href="Motor.html#is_active">is_active</a></li><li data-type='method'><a href="Motor.html#length">length</a></li><li data-type='method'><a href="Motor.html#namedtuple">namedtuple</a></li><li data-type='method'><a href="Motor.html#reverse">reverse</a></li><li data-type='method'><a href="Motor.html#stop">stop</a></li><li data-type='method'><a href="Motor.html#value">value</a></li></ul></li><li><a href="OutputDevice.html">OutputDevice</a><ul class='methods'><li data-type='method'><a href="OutputDevice.html#active_high">active_high</a></li><li data-type='method'><a href="OutputDevice.html#close">close</a></li><li data-type='method'><a href="OutputDevice.html#closed">closed</a></li><li data-type='method'><a href="OutputDevice.html#is_active">is_active</a></li><li data-type='method'><a href="OutputDevice.html#off">off</a></li><li data-type='method'><a href="OutputDevice.html#on">on</a></li><li data-type='method'><a href="OutputDevice.html#pin">pin</a></li><li data-type='method'><a href="OutputDevice.html#toggle">toggle</a></li><li data-type='method'><a href="OutputDevice.html#toString">toString</a></li><li data-type='method'><a href="OutputDevice.html#value">value</a></li></ul></li><li><a href="PiTraffic.html">PiTraffic</a></li><li><a href="PWMLED.html">PWMLED</a><ul class='methods'><li data-type='method'><a href="PWMLED.html#blink">blink</a></li><li data-type='method'><a href="PWMLED.html#close">close</a></li><li data-type='method'><a href="PWMLED.html#frequency">frequency</a></li><li data-type='method'><a href="PWMLED.html#is_active">is_active</a></li><li data-type='method'><a href="PWMLED.html#is_lit">is_lit</a></li><li data-type='method'><a href="PWMLED.html#off">off</a></li><li data-type='method'><a href="PWMLED.html#on">on</a></li><li data-type='method'><a href="PWMLED.html#pulse">pulse</a></li><li data-type='method'><a href="PWMLED.html#toggle">toggle</a></li><li data-type='method'><a href="PWMLED.html#value">value</a></li></ul></li><li><a href="PWMOutputDevice.html">PWMOutputDevice</a><ul class='methods'><li data-type='method'><a href="PWMOutputDevice.html#blink">blink</a></li><li data-type='method'><a href="PWMOutputDevice.html#close">close</a></li><li data-type='method'><a href="PWMOutputDevice.html#frequency">frequency</a></li><li data-type='method'><a href="PWMOutputDevice.html#is_active">is_active</a></li><li data-type='method'><a href="PWMOutputDevice.html#off">off</a></li><li data-type='method'><a href="PWMOutputDevice.html#on">on</a></li><li data-type='method'><a href="PWMOutputDevice.html#pulse">pulse</a></li><li data-type='method'><a href="PWMOutputDevice.html#toggle">toggle</a></li><li data-type='method'><a href="PWMOutputDevice.html#value">value</a></li></ul></li><li><a href="RGBLED.html">RGBLED</a><ul class='methods'><li data-type='method'><a href="RGBLED.html#close">close</a></li><li data-type='method'><a href="RGBLED.html#is_active">is_active</a></li><li data-type='method'><a href="RGBLED.html#off">off</a></li><li data-type='method'><a href="RGBLED.html#on">on</a></li><li data-type='method'><a href="RGBLED.html#toggle">toggle</a></li><li data-type='method'><a href="RGBLED.html#value">value</a></li></ul></li><li><a href="TrafficLights.html">TrafficLights</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">output_devices.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const Lock = require('rwlock');
const GPIODevice = require('./devices.js').GPIODevice;
const Device = require('./devices.js').Device;
const CompositeDevice = require('./devices.js').CompositeDevice;
const exc = require('./exc.js');
const inherit = require('./tools.js').inherit;

exports.OutputDevice = OutputDevice;
/**
 * Represents a generic GPIO output device.
 * Provides facilities common to GPIO output devices an {@link OutputDevice#on|on} method to switch the device on, a
 * corresponding {@link OutputDevice#off|off} method, and a {@link OutputDevice#toggle|toggle} method.
 *
 * @param {(int | Pin)} pin - The GPIO pin (in BCM numbering) or an instance of Pin that the device is connected to.
 * @param {boolean} [active_high] - If `true` (the default), the {@link OutputDevice#on|on} method will set the GPIO to HIGH.
 * If `false`, the :{@link OutputDevice#on|on} method will set the GPIO to LOW (the {@link OutputDevice#off|off} method always does the opposite).
 * @param {boolean} [initial_value] - If `false` (the default), the device will be off initially.
 * If `undefined`, the device will be left in whatever state the pin is found in when configured for output (warning: this can be on).  If `true`, the device will be switched on initially.
 *
 * @throws GPIOPinMissing - When pin is undefined.
 * @class
 * @augments GPIODevice
 */
function OutputDevice(pin, active_high, initial_value) {
    GPIODevice.call(this, pin);
    this._lock = new Lock();
    this.active_high((active_high === undefined) ? true : active_high);

    if (initial_value === undefined) {
        this._pin.pin_function('output');
    } else {
        this._pin.output_with_state(this._value_to_state(initial_value));
    }
}


OutputDevice.prototype = inherit(GPIODevice.prototype);
OutputDevice.prototype.constructor = OutputDevice;

/**
 * Internal method to apply active state high and convert the actual value to a logical value.
 *
 * @param {boolean|float} value - The value to be converted.
 * @returns {boolean} - The logical value of the pin.
 * @private
 */
OutputDevice.prototype._value_to_state = function(value) {
    return (value) ? this._active_state : this._inactive_state;
};

/**
 * Internal method used to write to the pin after mapping the request value.
 *
 * @param {float | boolean} value - The logical value that the pin should be changed to.
 * @private
 */
OutputDevice.prototype._write = function(value) {
    this._check_open(this);
    this._pin.state(this._value_to_state(value));
};

/**
* Turns the device on.
**/
OutputDevice.prototype.on = function() {
    this._pin._stop_blink();
    this._write(true);
};

/**
 * Turns the device off.
 */
OutputDevice.prototype.off = function() {
    this._pin._stop_blink();
    this._write(false);
};

/**
 *
 * This property can be set after construction; be warned that changing it
 * will invert {@link OutputDevice#value|value} (i.e. changing this property doesn't change
 * the device's pin state - it just changes how that state is interpreted).
 *
 * @param {boolean} [value] - When ``true``, the {@link OutputDevice#value|value} property is ``true`` when the device's
 * {@link OutputDevice#pin|pin} is high. When ``false`` the {@link OutputDevice#value|value} property is
 * ``true`` when the device's pin is low (i.e. the value is inverted).
 *
 */
OutputDevice.prototype.active_high = function(value) {
    if (value === undefined) {
        return this._active_state;
    }
    this._active_state = value;
    this._inactive_state = !value;
};

/**
 *
 * @param {boolean | float} [value] - When supplied the device output is changed to the value.
 * @returns {boolean | float} - When value is undefined, the function returns the current value of the device.
 */
OutputDevice.prototype.value = function(value) {
    if (value === undefined) {
        return this._read();
    }
    this._pin._stop_blink();
    this._write(value);
};

/**
 * Reverse the state of the device. If it's on, turn it off; if it's off, turn it on.
 */
OutputDevice.prototype.toggle = function() {
    const that = this;
    this._lock.readLock((release) => {
        if (that.is_active()) {
            that.off();
        } else {
            that.on();
        }
        release();
    });
};

exports.DigitalOutputDevice = DigitalOutputDevice;

/**
 * Represents a generic output device with typical on/off behaviour. This class extends {@link OutputDevice}
 * with a {@link DigitalOutputDevice#blink|blink} method which toggles the device state without further interaction.
 *
 * @param {(int | Pin)} pin - The GPIO pin (in BCM numbering) or an instance of Pin that the device is connected to.
 * @param {boolean} [active_high] - If `true` (the default), the {@link OutputDevice#on|on} method will set the GPIO to HIGH.
 * If `false`, the {@link OutputDevice#on|on} method will set the GPIO to LOW (the {@link OutputDevice#off|off} method always does the opposite).
 * @param {boolean} [initial_value] - If `false` (the default), the device will be off initially.
 * If `undefined`, the device will be left in whatever state the pin is found in when configured for output (warning: this can be on).  If `true`, the device will be switched on initially.
 *
 * @throws GPIOPinMissing - When pin is undefined.
 * @class
 * @augments OutputDevice
 */
function DigitalOutputDevice(pin, active_high, initial_value) {
    OutputDevice.call(this, pin, active_high, initial_value);
}

DigitalOutputDevice.prototype = inherit(OutputDevice.prototype);
DigitalOutputDevice.prototype.constructor = DigitalOutputDevice;

/**
 * Make the device turn on and off repeatedly.
 *
 * @param {float} on_time - Number of seconds on. Defaults to 1 second.
 * @param {float} off_time - Number of seconds off. Defaults to 1 second.
 * @param {int} n - Number of times to blink; ``None`` (the default) means forever.
 * @param {@callback} callback - Function to be called upon completion in the form (error, data).
 */
DigitalOutputDevice.prototype.blink = function(on_time, off_time, n, callback) {
    this._pin.blink(on_time, off_time, n, callback);
};

exports.LED = LED;

/**
 * Represents a light emitting diode (LED).
 *
 * Connect the cathode (short leg, flat side) of the LED to a ground pin; connect the anode (longer leg) to a limiting resistor; connect the other side of the limiting resistor to a GPIO pin (the limiting resistor can be placed either side of the LED).
 *
 * @example const LED = require('gpiozero').LED;
 *          var led = new LED(17);
 *          led.on();
 *
 * @param {(int | Pin)} pin - The GPIO pin (in BCM numbering) or an instance of Pin that the LED is connected to.
 * @param {boolean} [active_high] - If ``True`` (the default), the LED will operate normally with the circuit described above. If ``False`` you should wire the cathode to the GPIO pin, and the anode to a 3V3 pin (via a limiting resistor).
 * @param {boolean} [initial_value] - If `false` (the default), the device will be off initially.
 * If `undefined`, the device will be left in whatever state the pin is found in when configured for output (warning: this can be on).  If `true`, the device will be switched on initially.
 * @augments DigitalOutputDevice
 * @class
 *
 */
function LED(pin, active_high, initial_value) {
    DigitalOutputDevice.call(this, pin, active_high, initial_value);
}

LED.prototype = inherit(DigitalOutputDevice.prototype);
LED.prototype.constructor = LED;
/**
 * Friendly name for is_active.
 *
 * @returns {boolean} - Is true is LED is lit.
 */
LED.prototype.is_lit = function() {
    return this.is_active();
};


exports.Buzzer = Buzzer;
/**
 * Represents a digital buzzer component.
 *
 * @example const Buzzer = require ('gpiozero').Buzzer;
 *          bz = new Buzzer(3);
 *          bz.on();
 *
 * @param {int | Pin} pin -  The GPIO pin which the buzzer is attached to.
 * @param {boolean} active_high - If ``true`` (the default), the buzzer will operate normally with the circuit described above.
 * If ``false`` you should wire the cathode to the GPIO pin, and the anode to a 3V3 pin.
 * @param {boolean} initial_value - If ``false`` (the default), the buzzer will be silent initially.
 * If ``undefined``, the buzzer will be left in whatever state the pin is found in
 * when configured for output (warning: this can be on).  If ``true``, the buzzer will be switched on initially.
 * @class
 * @augments DigitalOutputDevice
 */
function Buzzer(pin, active_high, initial_value) {
    DigitalOutputDevice.call(this, pin, active_high, initial_value);
}

Buzzer.prototype = inherit(DigitalOutputDevice.prototype);
Buzzer.prototype.constructor = Buzzer;

/**
 * Make the buzzer switch on and off once a second.
 */
Buzzer.prototype.beep = function() {
    this.blink();
};

exports.PWMOutputDevice = PWMOutputDevice;

/**
 * Generic output device configured for pulse-width modulation (PWM).
 *
 * @param {int | Pin} pin - The GPIO pin which the device is attached to.
 * @param {boolean} active_high - If ``true`` (the default), the {@link PWMOutputDevice#on|on} method will set the GPIO to HIGH.
 * If ``false``, the {@link PWMOutputDevice#on|on} method will set the GPIO to LOW (the {@link PWMOutputDevice#off|off} method always does the opposite).
 * @param {int} initial_value - If ``0`` (the default), the device's duty cycle will be 0 initially.
 * Other values between 0 and 1 can be specified as an initial duty cycle.
 * Note that ``undefined`` cannot be specified (unlike the parent class) as there is no way to tell PWM not to alter the state of the pin.
 * @param {int} frequency - The frequency (in Hz) of pulses emitted to drive the device. Defaults to 100Hz.
 * @class
 *
 * @throws OutputDeviceBadValue - When intial_value is ``undefined``.
 */
function PWMOutputDevice(pin, active_high, initial_value, frequency) {
    if (initial_value !== undefined) {
        if (initial_value &lt; 0 || initial_value > 1) {
            throw new exc.OutputDeviceBadValue("initial_value must be between 0 and 1, actual=:" + initial_value);
        }
    }

    OutputDevice.call(this, pin, active_high, initial_value);

    try {
        this._pin.frequency(frequency === undefined ? 100 : frequency);
        this.value(initial_value === undefined ? 0 : initial_value);
    } catch (e) {
        this.close();
        throw e;
    }
}

PWMOutputDevice.prototype = inherit(OutputDevice.prototype);
PWMOutputDevice.prototype.constructor = PWMOutputDevice;
/**
 * The duty cycle of the PWM device. 0.0 is off, 1.0 is fully on.
 * Values in between may be specified for varying levels of power in the device.
 *
 * @param {float} [value] - When defined then sets the device duty cycle.
 * @returns {float} - When value is undefined then the current duty cycle is returned.
 */
PWMOutputDevice.prototype.value = function(value) {
    if (value === undefined) {
        return this._read();
    }
    this._pin._stop_blink();
    this._write(value);
};
/**
 * Internal method that converts the actual pin value to it's logical value.
 *
 * @returns {number} - Logical pin value.
 * @private
 */
PWMOutputDevice.prototype._read = function() {
    this._check_open();
    if (this.active_high()) {
        return this._pin.state();
    }
    return 1 - this._pin.state();
};

/**
 * Internal method used to convert a logical value to the state the pin needs to change to.
 *
 * @param {float} value - Logical value to set the device to.
 * @private
 * @throws OutputDeviceBadValue - Occurs if the value specified is not between 0 and 1.
 */
PWMOutputDevice.prototype._write = function(value) {
    if (!this.active_high()) {
        value = 1 - value;
    }
    if (value &lt; 0 || value > 1) {
        throw new exc.OutputDeviceBadValue("PWM value must be between 0 and 1");
    }
    this._check_open();
    this._pin.state(value);
};

/**
 * Sets or Gets the device frequency.
 *
 * @param {int} [value] - The new frequency for the device.
 * @returns {int} - If value is undefined then the current device frequency is returned.
 */
PWMOutputDevice.prototype.frequency = function(value) {
    if (value === undefined) {
        return this._pin.frequency();
    }
    this._pin.frequency(value);
};

/**
 *
 * @returns {boolean} - If the device has a value other than 0 then true.
 */
PWMOutputDevice.prototype.is_active = function() {
    return this.value() !== 0;
};

/**
 * Turn the device fully on.
 */
PWMOutputDevice.prototype.on = function() {
    this._pin._stop_blink();
    this._write(1);
};

/**
 * Turn the device off.
 */
PWMOutputDevice.prototype.off = function() {
    this._pin._stop_blink();
    this._write(0);
};

/**
 * Toggle the state of the device. If the device is currently off (value` is 0.0),
 * this changes it to "fully" on (`value` is 1.0).
 * If the device has a duty cycle (`value`) of 0.1, this will toggle it to 0.9, and so on.
 */
PWMOutputDevice.prototype.toggle = function() {
    this._pin._stop_blink();
    const newValue = 1 - this.value();
    this.value(newValue);
};

/**
 * Stop any actions such as blink and unlink from pin.
 */
PWMOutputDevice.prototype.close = function() {
    this._pin._stop_blink();
    this._pin.frequency(-1);
    OutputDevice.prototype.close.call(this);
};

/**
 * Make the device turn on and off repeatedly.
 *
 * @param {float} [on_time] - Number of seconds on. Defaults to 1 second.
 * @param {float} [off_time] - Number of seconds off. Defaults to 1 second.
 * @param {float} [fade_in_time] - Number of seconds to spend fading in. Defaults to 0.
 * @param {float} [fade_out_time] - Number of seconds to spend fading out. Defaults to 0.
 * @param {int} [n] - Number of times to blink; ``undefined`` (the default) means forever.
 * @param {@callback} [callback] - Function to be called after n loops.
 */
PWMOutputDevice.prototype.blink = function(on_time, off_time, fade_in_time, fade_out_time, n, callback) {
    this._pin.blink(on_time, off_time, fade_in_time, fade_out_time, n, undefined, callback);
};

/**
 * Make the device fade in and out repeatedly.
 *
 * @param {float} [fade_in_time] - Number of seconds to spend fading in. Defaults to 0.
 * @param {float} [fade_out_time] - Number of seconds to spend fading out. Defaults to 0.
 * @param {int} [n] - Number of times to blink; ``undefined`` (the default) means forever.
 * @param {@callback} [callback] - Function to be called after n loops.
 */
PWMOutputDevice.prototype.pulse = function(fade_in_time, fade_out_time, n, callback) {
    const on_time = 0,
        off_time = 0;

    this._pin.blink(on_time, off_time, fade_in_time, fade_out_time, n, undefined, callback);
};

exports.Motor = Motor;

/**
 * Represents a generic motor connected to a bi-directional motor driver circuit (i.e.  an `H-bridge`_).
 * Attach an `H-bridge`_ motor controller to your Pi; connect a power source (e.g. a battery pack or the 5V pin) to the controller; connect the outputs
 * of the controller board to the two terminals of the motor; connect the inputs of the controller board to two GPIO pins.
 *
 * @param {int} forward - The GPIO pin that the forward input of the motor driver chip is connected to.
 * @param {int} backward - The GPIO pin that the backward input of the motor driver chip is connected to.
 * @param {boolean} [pwm] - If ``true`` (the default), construct {@link PWMOutputDevice} instances for the motor controller pins, allowing both direction and variable speed control. If ``False``, construct {@link DigitalOutputDevice} instances, allowing only direction control.
 * @class
 * @augments CompositeDevice
 * @throws GPIOPinMissing - If either Forward or Backward pin is not provided.
 */
function Motor(forward, backward, pwm) {
    if (forward === undefined || backward === undefined) {
        throw new exc.GPIOPinMissing('Forward and Backward pins must be provided');
    }
    if (pwm === undefined || pwm === true) {
        CompositeDevice.call(this,undefined, [['forward_device', new PWMOutputDevice(forward)],
                                                ['backward_device', new PWMOutputDevice(backward)]]);
    } else {
        CompositeDevice.call(this, undefined, [['forward_device', new DigitalOutputDevice(forward)],
            ['backward_device', new DigitalOutputDevice(backward)]]);
    }
}

Motor.prototype = inherit(CompositeDevice.prototype);
Motor.prototype.constructor = Motor;

/**
 * Close down the output devices and release the pins.
 */
Motor.prototype.close = function() {
    if (this.forward_device !== undefined) {
        this.forward_device.close();
        this.forward_device = undefined;
    }

    if (this.backward_device !== undefined) {
        this.backward_device.close();
        this.backward_device = undefined;
    }
    OutputDevice.prototype.close.call(this);
};

/**
 *
 * @returns {boolean} - If true then the forward and backward devices are undefined.
 */
Motor.prototype.closed = function() {
    return (this.forward_device === undefined &amp;&amp; this.backward_device === undefined);
};
/**
 * Gets and Sets the motor speed between -1 (full backwards) and 1 (full forwards).
 *
 * @param {int} [value] - Motor speed.
 * @returns {number} - If value is undefined then returns the current speed.
 * @throws OutputDeviceBadValue - If the value is defined but not between 1 and -1.
 */
Motor.prototype.value = function(value) {
    if (value === undefined) {
        return this.forward_device.value() - this.backward_device.value();
    }

    if (value > 1 || value &lt; -1) {
        throw new exc.OutputDeviceBadValue("Motor value must be between -1 and 1, actual=:" + value);
    }

    if (value > 0) {
        this.forward(value);
    } else if (value &lt; 0) {
        this.backward(-value);
    } else {
        this.stop();
    }
};
/**
 *
 * @returns {boolean} - If the motor is currently running then ``true`` otherwise ``false``.
 */
Motor.prototype.is_active = function() {
    /*

    */
    return this.value() !== 0;
};

/**
 * Drive the motor forwards.
 *
 * @param {float} speed - The speed at which the motor should turn. Can be any value between 0 (stopped)
 * and the default 1 (maximum speed) if ``pwm`` was ``true`` when the class was constructed (and only 0 or 1 if not).
 *
 * @throws ValueError - When the speed is less than 0 or greater than 1.
 * @throws ValueError - When the speed is between 0 and 1 on non-pwm motors.
 */
Motor.prototype.forward = function(speed) {
    if (speed === undefined) {
        speed = 1;
    }

    if (speed &lt; 0 || speed > 1) {
        throw new exc.ValueError('forward speed must be between 0 and 1');
    }

    if (this.forward_device instanceof DigitalOutputDevice &amp;&amp; speed !== 1 &amp;&amp; speed !== 0) {
        throw new exc.ValueError('forward speed must be 0 or 1 with non-PWM Motors');
    }

    this.backward_device.off();
    this.forward_device.value(speed);
};

/**
 * Drive the motor backwards.
 *
 * @param {float} speed - The speed at which the motor should turn. Can be any value between 0 (stopped)
 * and the default 1 (maximum speed) if ``pwm`` was ``true`` when the class was constructed (and only 0 or 1 if not).
 *
 * @throws ValueError - When the speed is less than 0 or greater than 1.
 * @throws ValueError - When the speed is between 0 and 1 on non-pwm motors.
 */
Motor.prototype.backward = function(speed) {
    if (speed === undefined) {
        speed = 1;
    }

    if (speed &lt; 0 || speed > 1) {
        throw new exc.ValueError('backward speed must be between 0 and 1');
    }

    if (this.backward_device instanceof DigitalOutputDevice &amp;&amp; speed !== 1 &amp;&amp; speed !== 0) {
        throw new exc.ValueError('backward speed must be 0 or 1 with non-PWM Motors');
    }

    this.forward_device.off();
    this.backward_device.value(speed);
};

/**
 *     Reverse the current direction of the motor. If the motor is currently
 *     idle this does nothing. Otherwise, the motor's direction will be
 *     reversed at the current speed.
 */
Motor.prototype.reverse = function() {
    this.value(-1 * this.value());
};

/**
 * Stop the motor.
 */
Motor.prototype.stop = function() {
    this.forward_device.off();
    this.backward_device.off();
};

exports.PWMLED = PWMLED;

/**
 * Represents a light emitting diode (LED) with variable brightness.
 *
 * A typical configuration of such a device is to connect a GPIO pin to the
 * anode (long leg) of the LED, and the cathode (short leg) to ground, with
 * an optional resistor to prevent the LED from burning out.
 *
 * @param {int} pin - The GPIO pin which the LED is attached to.
 * @param {boolean} [active_high] - If ``true`` (the default), the {@link PWMLED#on|on} method will set the GPIO to HIGH.
 * If ``false``, the {@link PWMLED#on|on} method will set the GPIO to LOW (the {@link PWMLED#off|off} method always does
 * the opposite).
 * @param {float} [initial_value] - If ``0`` (the default), the LED will be off initially. Other values
 * between 0 and 1 can be specified as an initial brightness for the LED. Note that ``undefined`` cannot be specified
 * (unlike the parent class) as there is no way to tell PWM not to alter the state of the pin.
 * @param {int} [frequency] - The frequency (in Hz) of pulses emitted to drive the LED. Defaults to 100Hz.
 * @class
 * @augments PWMOutputDevice
 */
function PWMLED(pin, active_high, initial_value, frequency) {
    PWMOutputDevice.call(this, pin, active_high, initial_value, frequency);
}

PWMLED.prototype = inherit(PWMOutputDevice.prototype);
PWMLED.prototype.constructor = PWMLED;

/**
 *
 * @returns {boolean} - Alias for {@link PWMOutputDevice#is_active|is_active}.
 */
PWMLED.prototype.is_lit = function() {
    return this.is_active();
};

/**
 *
 * Extends :class:`Device` and represents a full color LED component (composed of red, green, and blue LEDs).
 *
 * Connect the common cathode (longest leg) to a ground pin; connect each of
 * the other legs (representing the red, green, and blue anodes) to any GPIO
 * pins.  You can either use three limiting resistors (one per anode) or a
 * single limiting resistor on the cathode.
 *
 * @param {int} red - The GPIO pin that controls the red component of the RGB LED.
 * @param {int} green - The GPIO pin that controls the green component of the RGB LED.
 * @param {int} blue - The GPIO pin that controls the blue component of the RGB LED.
 * @param {boolean} [active_high] - Set to ``true`` (the default) for common cathode RGB LEDs. If you are
 *      using a common anode RGB LED, set this to ``false``.
 * @param {Array} [initial_value] - The initial color for the RGB LED. Defaults to black ``[0, 0, 0]``.
 * @param {boolean} [pwm] - If ``true`` (the default), construct {@link PWMLED} instances for
 *      each component of the RGBLED. If ``false``, construct regular {@link LED} instances,
 *      which prevents smooth color graduations.
 * @class
 * @throws GPIOPinMissing - If one of the pins is not specified.
 */

function RGBLED(red, green, blue, active_high, initial_value, pwm) {
    this._leds = [];
    if (red === undefined || blue === undefined || green === undefined) {
        throw new exc.GPIOPinMissing('red, green, and blue pins must be provided');
    }
    pwm = (pwm === undefined ? true : pwm);
    var LEDClass = pwm ? PWMLED : LED;
    Device.call(this);
    this._leds = [new LEDClass(red, active_high), new LEDClass(green, active_high), new LEDClass(blue, active_high)];
    if (initial_value === undefined) {
        initial_value = [0, 0, 0];
    }
    this.value(initial_value);
}

exports.RGBLED = RGBLED;
RGBLED.prototype = inherit(Device.prototype);
RGBLED.prototype.constructor = RGBLED;

/**
 *  Represents the color of the LED as an RGB 3-tuple of ``[red, green, blue]``
 *  where each value is between 0 and 1 if ``pwm`` was ``true`` when the class was constructed
 *  (and only 0 or 1 if not).
 *
 * @param {Array} [value] - If set, the value for each component will be updated.
 * @returns {Array} - If ``value`` is ``undefined`` then returns the current value for each component.
 *
 * @throws OutputDeviceBadValue - If three values are not passed as an array in value.
 * @throws OutputDeviceBadValue - If any of the RGB values are not between 0 and 1.
 * @throws OutputDeviceBadValue - If pwm is false but a value is between 0 and 1.
 */
RGBLED.prototype.value = function(value) {
    if (value === undefined) {
        return [this.red, this.green, this.blue];
    }
    if (value.length &lt; 3) {
        throw new exc.OutputDeviceBadValue('RGB values must be an array of three components');
    }
    var i;
    for (i = 0; i &lt; 3; i++) {
        if (value[i] &lt; 0 || value[i] > 1) {
            throw new exc.OutputDeviceBadValue('each RGB component must be between 0 and 1');
        }
        if (this._leds[i] instanceof LED) {
            if (value[i] !== 0 &amp;&amp; value[i] !== 1) {
                throw new exc.OutputDeviceBadValue('each RGB color component must be 0 or 1 with non-PWM RGBLEDs');
            }
        }
    }

    for (i = 0; i &lt; 3; i++) {
        this._leds[i].value(value[i]);
    }
    this.red = this._leds[0].value();
    this.green = this._leds[1].value();
    this.blue = this._leds[2].value();
};

/**
 * Close each pin and release for reuse.
 */
RGBLED.prototype.close = function() {
    var i;
    for (i = 0; i &lt; 3; i++) {
        if (this._leds[i] !== undefined) {
            this._leds[i].close();
            this._leds[i] = undefined;
        }
    }
    this._leds = [];
    Device.prototype.close.call(this);
};

/**
 *
 * @returns {boolean} - If the LED is currently active (not black) then ``true`` otherwise ``false``.
 */
RGBLED.prototype.is_active = function() {
    return (this.value()[0] + this.value()[1] + this.value()[2] > 0);
};

/**
 * Turn the LED on. This equivalent to setting the LED color to white ``[1, 1, 1]``.
 */
RGBLED.prototype.on = function() {
    this.value([1, 1, 1]);
};

/**
 * Turn the LED off. This equivalent to setting the LED color to black ``[0, 0, 0]``.
 */
RGBLED.prototype.off = function() {
    this.value([0, 0, 0]);
};

/**
 * Toggle the state of the device. If the device is currently off (`value` is ``[0, 0, 0[``),
 * this changes it to "fully" on (`value` is ``[1, 1, 1]``).
 * If the device has a specific color, this method inverts the color.
 */
RGBLED.prototype.toggle = function() {
    var current = this.value();
    this.value([1 - current[0], 1 - current[1], 1 - current[2]]);
};

RGBLED.prototype.closed = function() {
    return this._leds.length === 0;
};

/*RGBLED.prototype.blink = function(on_time, off_time, fade_in_time, fade_out_time, on_color, off_color, n, callback) {

    /*
    Make the device turn on and off repeatedly.

    :param float on_time:
        Number of seconds on. Defaults to 1 second.

    :param float off_time:
        Number of seconds off. Defaults to 1 second.

    :param float fade_in_time:
        Number of seconds to spend fading in. Defaults to 0.

    :param float fade_out_time:
        Number of seconds to spend fading out. Defaults to 0.

    :param tuple on_color:
            The color to use when the LED is "on". Defaults to white.

    :param tuple off_color:
        The color to use when the LED is "off". Defaults to black.

    :param int n:
        Number of times to blink; ``None`` (the default) means forever.

    
    if (this._leds[0] instanceof LED) {
        if (fade_in_time !== undefined) {
            throw new  exc.ValueError('fade_in_time must be 0 with non-PWM RGBLEDs');
        }
        if (fade_out_time !== undefined) {
            throw new exc.ValueError('fade_out_time must be 0 with non-PWM RGBLEDs');
        }
    }

    this._leds[0].blink (on_time, off_time, fade_in_time, fade_out_time, n, callback);
    this._leds[1].blink (on_time, off_time, fade_in_time, fade_out_time, n, callback);
    this._leds[2].blink (on_time, off_time, fade_in_time, fade_out_time, n, callback);

};

RGBLED.prototype._stop_blink = function () {
    this._leds[0]._pin._stop_blink();
    this._leds[1]._pin._stop_blink();
    this._leds[2]._pin._stop_blink();
}

 /* def _blink_device(
            self, on_time, off_time, fade_in_time, fade_out_time, on_color,
            off_color, n, fps=25):
        # Define some simple lambdas to perform linear interpolation between
        # off_color and on_color
        lerp = lambda t, fade_in: tuple(
            (1 - t) * off + t * on
            if fade_in else
            (1 - t) * on + t * off
            for off, on in zip(off_color, on_color)
            )
        sequence = []
        if fade_in_time > 0:
            sequence += [
                (lerp(i * (1 / fps) / fade_in_time, True), 1 / fps)
                for i in range(int(fps * fade_in_time))
                ]
        sequence.append((on_color, on_time))
        if fade_out_time > 0:
            sequence += [
                (lerp(i * (1 / fps) / fade_out_time, False), 1 / fps)
                for i in range(int(fps * fade_out_time))
                ]
        sequence.append((off_color, off_time))
        sequence = (
                cycle(sequence) if n is None else
                chain.from_iterable(repeat(sequence, n))
                )
        for l in self._leds:
            l._controller = self
        for value, delay in sequence:
            for l, v in zip(self._leds, value):
                l._write(v)
            if self._blink_thread.stopping.wait(delay):
                break
*/


/*
class RGBLED(SourceMixin, Device):


    def blink(
            self, on_time=1, off_time=1, fade_in_time=0, fade_out_time=0,
            on_color=(1, 1, 1), off_color=(0, 0, 0), n=None, background=True):
        """
        Make the device turn on and off repeatedly.

        :param float on_time:
            Number of seconds on. Defaults to 1 second.

        :param float off_time:
            Number of seconds off. Defaults to 1 second.

        :param float fade_in_time:
            Number of seconds to spend fading in. Defaults to 0. Must be 0 if
            ``pwm`` was ``False`` when the class was constructed
            (:exc:`ValueError` will be raised if not).

        :param float fade_out_time:
            Number of seconds to spend fading out. Defaults to 0. Must be 0 if
            ``pwm`` was ``False`` when the class was constructed
            (:exc:`ValueError` will be raised if not).

        :param tuple on_color:
            The color to use when the LED is "on". Defaults to white.

        :param tuple off_color:
            The color to use when the LED is "off". Defaults to black.

        :param int n:
            Number of times to blink; ``None`` (the default) means forever.

        :param bool background:
            If ``True`` (the default), start a background thread to continue
            blinking and return immediately. If ``False``, only return when the
            blink is finished (warning: the default value of *n* will result in
            this method never returning).
        """
        if isinstance(self._leds[0], LED):
            if fade_in_time:
                raise ValueError('fade_in_time must be 0 with non-PWM RGBLEDs')
            if fade_out_time:
                raise ValueError('fade_out_time must be 0 with non-PWM RGBLEDs')
        
    def pulse(
            self, fade_in_time=1, fade_out_time=1,
            on_color=(1, 1, 1), off_color=(0, 0, 0), n=None, background=True):
        """
        Make the device fade in and out repeatedly.

        :param float fade_in_time:
            Number of seconds to spend fading in. Defaults to 1.

        :param float fade_out_time:
            Number of seconds to spend fading out. Defaults to 1.

        :param tuple on_color:
            The color to use when the LED is "on". Defaults to white.

        :param tuple off_color:
            The color to use when the LED is "off". Defaults to black.

        :param int n:
            Number of times to pulse; ``None`` (the default) means forever.

        :param bool background:
            If ``True`` (the default), start a background thread to continue
            pulsing and return immediately. If ``False``, only return when the
            pulse is finished (warning: the default value of *n* will result in
            this method never returning).
        """
        on_time = off_time = 0
        self.blink(
            on_time, off_time, fade_in_time, fade_out_time,
            on_color, off_color, n, background
        )

    def _stop_blink(self, led=None):
        # If this is called with a single led, we stop all blinking anyway
        if self._blink_thread:
            self._blink_thread.stop()
            self._blink_thread = None

   


*/</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
<<<<<<< Updated upstream
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Wed Dec 28 2016 22:07:10 GMT+0000 (GMT) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
=======
<<<<<<< Updated upstream
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Wed Dec 28 2016 22:05:35 GMT+0000 (GMT) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
=======
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Wed Dec 28 2016 22:04:31 GMT+0000 (GMT) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
>>>>>>> Stashed changes
>>>>>>> Stashed changes
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
